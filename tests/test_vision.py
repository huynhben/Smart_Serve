"""Tests for the vision module.

AI-Generated Tests - Course AI Policy Compliance:
Prompt used: "Create comprehensive unit tests for the vision.py module 
that includes tests for _load_foods, _build_text_corpus, _ensure_model, 
_ensure_text_embeddings, and match_image_to_foods functions. Follow the testing 
pattern from the provided storage test example. Include fixtures, edge cases, 
mocking of external dependencies (CLIP model), and test caching behavior."

Updated: December 5, 2024 - Fixed torch mocking issues
Generated by: Claude (Anthropic)
All tests below were AI-generated and reviewed for correctness.
"""

from __future__ import annotations

import json
from pathlib import Path
from unittest.mock import MagicMock, mock_open, patch

import numpy as np
import pytest
from PIL import Image

from food_tracker.vision import (
    _build_text_corpus,
    _ensure_model,
    _ensure_text_embeddings,
    _load_foods,
    match_image_to_foods,
    FOODS_FILE,
    EMBED_FILE,
)


@pytest.fixture
def sample_foods_data():
    """Sample foods.json data for testing.
    AI-Generated: Creates sample food data structure for testing."""
    return [
        {
            "name": "Apple",
            "serving_size": "1 medium",
            "calories": 95.0,
            "macronutrients": {"carbs": 25.0, "protein": 0.5},
            "aliases": ["red apple", "green apple"],
        },
        {
            "name": "Banana",
            "serving_size": "1 medium",
            "calories": 105.0,
            "macronutrients": {"carbs": 27.0, "protein": 1.3},
            "aliases": ["yellow banana"],
        },
        {
            "name": "Chicken Breast",
            "serving_size": "100g",
            "calories": 165.0,
            "macronutrients": {"protein": 31.0, "fat": 3.6},
            "aliases": [],
        },
    ]


@pytest.fixture
def mock_foods_file(tmp_path, sample_foods_data):
    """Create a temporary foods.json file.
    AI-Generated: Sets up temporary test file."""
    foods_file = tmp_path / "foods.json"
    with foods_file.open("w", encoding="utf8") as f:
        json.dump(sample_foods_data, f)
    return foods_file


@pytest.fixture
def mock_image_bytes():
    """Create sample image bytes for testing.
    AI-Generated: Creates a simple RGB image for testing image processing."""
    img = Image.new("RGB", (224, 224), color="red")
    from io import BytesIO

    buf = BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()


@pytest.fixture(autouse=True)
def reset_module_cache():
    """Reset module-level cache before each test.
    AI-Generated: Ensures test isolation by clearing module cache."""
    import food_tracker.vision as img_rec

    img_rec._model = None
    img_rec._processor = None
    img_rec._text_embeddings = None
    img_rec._food_records = None
    yield
    # Reset again after test
    img_rec._model = None
    img_rec._processor = None
    img_rec._text_embeddings = None
    img_rec._food_records = None


class TestLoadFoods:
    """Tests for _load_foods function.
    AI-Generated: Test class for food loading functionality."""

    def test_load_foods_from_file(self, monkeypatch, mock_foods_file, sample_foods_data):
        """Test loading foods from JSON file.
        AI-Generated: Verifies basic file loading functionality."""
        monkeypatch.setattr("food_tracker.vision.FOODS_FILE", mock_foods_file)
        foods = _load_foods()
        assert len(foods) == 3
        assert foods[0]["name"] == "Apple"
        assert foods[1]["name"] == "Banana"
        assert foods[2]["name"] == "Chicken Breast"

    def test_load_foods_caches_result(self, monkeypatch, mock_foods_file):
        """Test that _load_foods caches the result.
        AI-Generated: Verifies caching behavior to avoid redundant file I/O."""
        monkeypatch.setattr("food_tracker.vision.FOODS_FILE", mock_foods_file)
        foods1 = _load_foods()
        foods2 = _load_foods()
        assert foods1 is foods2  # Same object reference

    def test_load_foods_handles_empty_file(self, monkeypatch, tmp_path):
        """Test loading from an empty JSON array.
        AI-Generated: Tests edge case of empty food database."""
        empty_file = tmp_path / "empty.json"
        with empty_file.open("w", encoding="utf8") as f:
            json.dump([], f)
        monkeypatch.setattr("food_tracker.vision.FOODS_FILE", empty_file)
        
        import food_tracker.vision as img_rec
        img_rec._food_records = None
        
        foods = _load_foods()
        assert foods == []


class TestBuildTextCorpus:
    """Tests for _build_text_corpus function.
    AI-Generated: Test class for text corpus building."""

    def test_build_text_corpus_with_aliases(self, sample_foods_data):
        """Test building text corpus including aliases.
        AI-Generated: Verifies that food names and aliases are combined correctly."""
        texts = _build_text_corpus(sample_foods_data)
        assert len(texts) == 3
        assert "Apple" in texts[0]
        assert "red apple" in texts[0]
        assert "green apple" in texts[0]
        assert "Banana" in texts[1]
        assert "yellow banana" in texts[1]

    def test_build_text_corpus_without_aliases(self):
        """Test building text corpus for foods without aliases.
        AI-Generated: Tests foods that have no aliases defined."""
        foods = [{"name": "Pizza", "serving_size": "1 slice", "calories": 285.0}]
        texts = _build_text_corpus(foods)
        assert len(texts) == 1
        assert texts[0] == "Pizza"

    def test_build_text_corpus_empty_list(self):
        """Test building text corpus from empty list.
        AI-Generated: Edge case for empty input."""
        texts = _build_text_corpus([])
        assert texts == []

    def test_build_text_corpus_handles_missing_name(self):
        """Test building text corpus with missing name field.
        AI-Generated: Tests robustness when required fields are missing."""
        foods = [{"serving_size": "100g", "calories": 200.0}]
        texts = _build_text_corpus(foods)
        assert len(texts) == 1
        assert texts[0] == ""


class TestEnsureModel:
    """Tests for _ensure_model function.
    AI-Generated: Test class for CLIP model initialization."""

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision.CLIPModel")
    @patch("food_tracker.vision.CLIPProcessor")
    def test_ensure_model_loads_clip(self, mock_processor_class, mock_model_class, mock_torch):
        """Test that _ensure_model loads CLIP model and processor.
        AI-Generated: Verifies correct loading of HuggingFace CLIP components."""
        mock_model = MagicMock()
        mock_processor = MagicMock()
        mock_model_class.from_pretrained.return_value = mock_model
        mock_processor_class.from_pretrained.return_value = mock_processor

        _ensure_model()

        mock_model_class.from_pretrained.assert_called_once_with("openai/clip-vit-base-patch32")
        mock_processor_class.from_pretrained.assert_called_once_with("openai/clip-vit-base-patch32")
        mock_model.eval.assert_called_once()

    @patch("food_tracker.vision.CLIPModel", None)
    @patch("food_tracker.vision.CLIPProcessor", None)
    def test_ensure_model_raises_without_dependencies(self):
        """Test that _ensure_model raises error when dependencies missing.
        AI-Generated: Tests graceful failure when PyTorch/transformers not installed."""
        with pytest.raises(RuntimeError, match="CLIP dependencies not installed"):
            _ensure_model()

    @patch("food_tracker.vision.CLIPModel")
    @patch("food_tracker.vision.CLIPProcessor")
    def test_ensure_model_caches_instances(self, mock_processor_class, mock_model_class):
        """Test that _ensure_model caches model and processor.
        AI-Generated: Verifies that model is loaded only once for efficiency."""
        mock_model = MagicMock()
        mock_processor = MagicMock()
        mock_model_class.from_pretrained.return_value = mock_model
        mock_processor_class.from_pretrained.return_value = mock_processor

        _ensure_model()
        _ensure_model()  # Call again

        # Should only load once
        assert mock_model_class.from_pretrained.call_count == 1
        assert mock_processor_class.from_pretrained.call_count == 1


class TestEnsureTextEmbeddings:
    """Tests for _ensure_text_embeddings function.
    AI-Generated: Test class for text embedding computation and caching."""

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision._load_foods")
    @patch("food_tracker.vision._ensure_model")
    @patch("food_tracker.vision._processor")
    @patch("food_tracker.vision._model")
    def test_ensure_text_embeddings_computes_fresh(
        self, mock_model, mock_processor, mock_ensure_model, mock_load_foods, mock_torch, sample_foods_data, tmp_path, monkeypatch
    ):
        """Test computing text embeddings from scratch.
        AI-Generated: Verifies embeddings are computed when no cache exists."""
        monkeypatch.setattr("food_tracker.vision.EMBED_FILE", tmp_path / "embeddings.npz")
        mock_load_foods.return_value = sample_foods_data
        
        # Mock torch.no_grad()
        mock_torch.no_grad.return_value.__enter__ = MagicMock()
        mock_torch.no_grad.return_value.__exit__ = MagicMock()
        
        # Mock CLIP outputs
        mock_text_features = MagicMock()
        mock_text_features.cpu.return_value.numpy.return_value = np.random.randn(3, 512)
        mock_model.get_text_features.return_value = mock_text_features
        mock_model.device = "cpu"
        mock_processor.return_value = {"input_ids": MagicMock()}

        import food_tracker.vision as img_rec
        img_rec._processor = mock_processor
        img_rec._model = mock_model

        _ensure_text_embeddings()

        assert img_rec._text_embeddings is not None
        assert img_rec._text_embeddings.shape[0] == 3

    @patch("food_tracker.vision._load_foods")
    def test_ensure_text_embeddings_loads_from_disk(
        self, mock_load_foods, sample_foods_data, tmp_path, monkeypatch
    ):
        """Test loading precomputed embeddings from disk.
        AI-Generated: Verifies cached embeddings are loaded correctly."""
        embed_file = tmp_path / "embeddings.npz"
        embeddings = np.random.randn(3, 512).astype(np.float32)
        names = np.array(["Apple", "Banana", "Chicken Breast"], dtype=object)
        np.savez_compressed(embed_file, embeddings=embeddings, names=names)

        monkeypatch.setattr("food_tracker.vision.EMBED_FILE", embed_file)
        mock_load_foods.return_value = sample_foods_data

        _ensure_text_embeddings()

        import food_tracker.vision as img_rec
        assert img_rec._text_embeddings is not None
        assert img_rec._text_embeddings.shape == (3, 512)

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision._load_foods")
    def test_ensure_text_embeddings_recomputes_on_size_mismatch(
        self, mock_load_foods, mock_torch, sample_foods_data, tmp_path, monkeypatch
    ):
        """Test recomputing embeddings when size doesn't match foods.
        AI-Generated: Tests cache invalidation when food database changes."""
        embed_file = tmp_path / "embeddings.npz"
        # Save embeddings with wrong size
        embeddings = np.random.randn(2, 512).astype(np.float32)
        np.savez_compressed(embed_file, embeddings=embeddings)

        monkeypatch.setattr("food_tracker.vision.EMBED_FILE", embed_file)
        mock_load_foods.return_value = sample_foods_data
        
        # Mock torch.no_grad()
        mock_torch.no_grad.return_value.__enter__ = MagicMock()
        mock_torch.no_grad.return_value.__exit__ = MagicMock()

        with patch("food_tracker.vision._ensure_model") as mock_ensure_model:
            mock_model = MagicMock()
            mock_processor = MagicMock()
            mock_text_features = MagicMock()
            mock_text_features.cpu.return_value.numpy.return_value = np.random.randn(3, 512)
            mock_model.get_text_features.return_value = mock_text_features
            mock_model.device = "cpu"
            mock_processor.return_value = {"input_ids": MagicMock()}

            import food_tracker.vision as img_rec
            img_rec._processor = mock_processor
            img_rec._model = mock_model

            _ensure_text_embeddings()

            # Should have recomputed with correct size
            assert img_rec._text_embeddings.shape[0] == 3

    def test_ensure_text_embeddings_uses_cache(self):
        """Test that _ensure_text_embeddings uses cached embeddings.
        AI-Generated: Verifies in-memory cache is used when available."""
        import food_tracker.vision as img_rec
        
        # Set cached embeddings
        img_rec._text_embeddings = np.random.randn(3, 512)
        cached_embeddings = img_rec._text_embeddings

        _ensure_text_embeddings()

        # Should use cached version
        assert img_rec._text_embeddings is cached_embeddings


class TestMatchImageToFoods:
    """Tests for match_image_to_foods function.
    AI-Generated: Test class for main image matching functionality."""

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision._load_foods")
    @patch("food_tracker.vision._ensure_text_embeddings")
    @patch("food_tracker.vision._ensure_model")
    @patch("food_tracker.vision._processor")
    @patch("food_tracker.vision._model")
    def test_match_image_to_foods_returns_top_matches(
        self,
        mock_model,
        mock_processor,
        mock_ensure_model,
        mock_ensure_text_embeddings,
        mock_load_foods,
        mock_torch,
        sample_foods_data,
        mock_image_bytes,
    ):
        """Test matching image to foods returns top K results.
        AI-Generated: Verifies core functionality of image-to-food matching."""
        mock_load_foods.return_value = sample_foods_data
        
        # Mock torch.no_grad()
        mock_torch.no_grad.return_value.__enter__ = MagicMock()
        mock_torch.no_grad.return_value.__exit__ = MagicMock()
        
        # Set up text embeddings
        import food_tracker.vision as img_rec
        img_rec._text_embeddings = np.random.randn(3, 512)
        
        # Mock image feature extraction
        mock_image_features = MagicMock()
        mock_image_features.cpu.return_value.numpy.return_value = np.random.randn(1, 512)
        mock_model.get_image_features.return_value = mock_image_features
        mock_model.device = "cpu"
        mock_processor.return_value = {"pixel_values": MagicMock()}
        
        img_rec._processor = mock_processor
        img_rec._model = mock_model

        results = match_image_to_foods(mock_image_bytes, top_k=2)

        assert len(results) == 2
        assert all("food" in r for r in results)
        assert all("confidence" in r for r in results)
        assert all(isinstance(r["confidence"], float) for r in results)
        assert all(0 <= r["confidence"] <= 1 for r in results)

    @patch("food_tracker.vision._load_foods")
    @patch("food_tracker.vision._ensure_text_embeddings")
    def test_match_image_returns_empty_when_no_embeddings(
        self, mock_ensure_text_embeddings, mock_load_foods, mock_image_bytes
    ):
        """Test that match returns empty list when embeddings unavailable.
        AI-Generated: Tests graceful handling when system is not initialized."""
        mock_load_foods.return_value = []
        
        import food_tracker.vision as img_rec
        img_rec._text_embeddings = None

        results = match_image_to_foods(mock_image_bytes, top_k=5)

        assert results == []

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision._load_foods")
    @patch("food_tracker.vision._ensure_text_embeddings")
    @patch("food_tracker.vision._ensure_model")
    @patch("food_tracker.vision._processor")
    @patch("food_tracker.vision._model")
    def test_match_image_handles_top_k_greater_than_foods(
        self,
        mock_model,
        mock_processor,
        mock_ensure_model,
        mock_ensure_text_embeddings,
        mock_load_foods,
        mock_torch,
        sample_foods_data,
        mock_image_bytes,
    ):
        """Test matching with top_k greater than number of foods.
        AI-Generated: Tests boundary condition when requesting more results than available."""
        mock_load_foods.return_value = sample_foods_data
        
        # Mock torch.no_grad()
        mock_torch.no_grad.return_value.__enter__ = MagicMock()
        mock_torch.no_grad.return_value.__exit__ = MagicMock()
        
        import food_tracker.vision as img_rec
        img_rec._text_embeddings = np.random.randn(3, 512)
        
        mock_image_features = MagicMock()
        mock_image_features.cpu.return_value.numpy.return_value = np.random.randn(1, 512)
        mock_model.get_image_features.return_value = mock_image_features
        mock_model.device = "cpu"
        mock_processor.return_value = {"pixel_values": MagicMock()}
        
        img_rec._processor = mock_processor
        img_rec._model = mock_model

        results = match_image_to_foods(mock_image_bytes, top_k=10)

        # Should return all 3 foods even though top_k is 10
        assert len(results) == 3

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision._load_foods")
    @patch("food_tracker.vision._ensure_text_embeddings")
    @patch("food_tracker.vision._ensure_model")
    @patch("food_tracker.vision._processor")
    @patch("food_tracker.vision._model")
    def test_match_image_sorts_by_confidence(
        self,
        mock_model,
        mock_processor,
        mock_ensure_model,
        mock_ensure_text_embeddings,
        mock_load_foods,
        mock_torch,
        sample_foods_data,
        mock_image_bytes,
    ):
        """Test that results are sorted by confidence descending.
        AI-Generated: Verifies results are ordered by relevance score."""
        mock_load_foods.return_value = sample_foods_data
        
        # Mock torch.no_grad()
        mock_torch.no_grad.return_value.__enter__ = MagicMock()
        mock_torch.no_grad.return_value.__exit__ = MagicMock()
        
        import food_tracker.vision as img_rec
        # Create embeddings that will give predictable similarities
        img_rec._text_embeddings = np.array([
            [1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0],
        ], dtype=float)
        
        mock_image_features = MagicMock()
        # Image vector most similar to third food
        mock_image_features.cpu.return_value.numpy.return_value = np.array([[0.0, 0.0, 1.0]])
        mock_model.get_image_features.return_value = mock_image_features
        mock_model.device = "cpu"
        mock_processor.return_value = {"pixel_values": MagicMock()}
        
        img_rec._processor = mock_processor
        img_rec._model = mock_model

        results = match_image_to_foods(mock_image_bytes, top_k=3)

        # Results should be sorted by confidence
        confidences = [r["confidence"] for r in results]
        assert confidences == sorted(confidences, reverse=True)
        # First result should be the third food (Chicken Breast)
        assert results[0]["food"]["name"] == "Chicken Breast"

    def test_match_image_with_invalid_image_bytes(self):
        """Test matching with invalid image bytes.
        AI-Generated: Tests error handling for corrupted image data."""
        import food_tracker.vision as img_rec
        img_rec._text_embeddings = np.random.randn(3, 512)
        
        with pytest.raises(Exception):  # PIL will raise an error
            match_image_to_foods(b"not valid image data", top_k=5)


# ============================================================================
# INTEGRATION TESTS
# AI-Generated: Integration tests for complete workflow
# ============================================================================

class TestImageRecognitionIntegration:
    """Integration tests for complete image recognition workflow.
    AI-Generated: Tests end-to-end functionality with multiple components."""

    @patch("food_tracker.vision.torch")
    @patch("food_tracker.vision.CLIPModel")
    @patch("food_tracker.vision.CLIPProcessor")
    def test_complete_workflow_from_image_to_results(
        self, mock_processor_class, mock_model_class, mock_torch, tmp_path, monkeypatch, mock_image_bytes
    ):
        """Test complete workflow: load foods, build embeddings, match image.
        AI-Generated: Integration test covering full image recognition pipeline."""
        # Setup test data
        foods_data = [
            {"name": "Apple", "serving_size": "1 medium", "calories": 95.0, "aliases": ["red apple"]},
            {"name": "Banana", "serving_size": "1 medium", "calories": 105.0, "aliases": []},
        ]
        foods_file = tmp_path / "foods.json"
        with foods_file.open("w", encoding="utf8") as f:
            json.dump(foods_data, f)
        
        embed_file = tmp_path / "embeddings.npz"
        monkeypatch.setattr("food_tracker.vision.FOODS_FILE", foods_file)
        monkeypatch.setattr("food_tracker.vision.EMBED_FILE", embed_file)
        
        # Mock torch.no_grad()
        mock_torch.no_grad.return_value.__enter__ = MagicMock()
        mock_torch.no_grad.return_value.__exit__ = MagicMock()
        
        # Setup mocks
        mock_model = MagicMock()
        mock_processor = MagicMock()
        mock_model_class.from_pretrained.return_value = mock_model
        mock_processor_class.from_pretrained.return_value = mock_processor
        
        # Mock text embedding computation
        mock_text_features = MagicMock()
        mock_text_features.cpu.return_value.numpy.return_value = np.array([[1.0, 0.0], [0.0, 1.0]])
        
        # Mock image embedding computation
        mock_image_features = MagicMock()
        mock_image_features.cpu.return_value.numpy.return_value = np.array([[0.9, 0.1]])
        
        mock_model.get_text_features.return_value = mock_text_features
        mock_model.get_image_features.return_value = mock_image_features
        mock_model.device = "cpu"
        mock_processor.return_value = {"input_ids": MagicMock(), "pixel_values": MagicMock()}
        
        # Execute complete workflow
        results = match_image_to_foods(mock_image_bytes, top_k=2)
        
        # Verify results
        assert len(results) == 2
        assert results[0]["food"]["name"] in ["Apple", "Banana"]
        assert all(isinstance(r["confidence"], float) for r in results)
        assert results[0]["confidence"] >= results[1]["confidence"]  # Sorted by confidence